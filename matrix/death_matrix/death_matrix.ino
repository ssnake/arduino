#define BA {B01110000,B10001000,B10001000,B11111000,B10001000,B10001000}
#define BB {B11110000,B10001000,B10001000,B11110000,B10001000,B11111000}
#define BC {B11111000,B10000000,B10000000,B10000000,B10000000,B11111000}
#define BD {B11110000,B10001000,B10001000,B10001000,B10001000,B11110000}
#define BE {B11111000,B10000000,B10000000,B11110000,B10000000,B11111000}
#define BF {B11111000,B10000000,B10000000,B11110000,B10000000,B10000000}
#define BG {B01110000,B10001000,B10000000,B10011000,B10001000,B01110000}
#define BH {B10001000,B10001000,B11111000,B10001000,B10001000,B10001000}
#define BI {B11111000,B00100000,B00100000,B00100000,B00100000,B11111000}
#define BJ {B00111000,B00010000,B00010000,B00010000,B10010000,B01100000}
#define BM {B10001000,B11011000,B10101000,B10101000,B10001000,B10001000}
#define BN {B10001000,B11001000,B10101000,B10101000,B10011000,B10001000}
#define BL {B10000000,B10000000,B10000000,B10000000,B10000000,B11111000}
#define BO {B01110000,B10001000,B10001000,B10001000,B10001000,B01110000}
#define BP {B11110000,B10001000,B10001000,B11110000,B10000000,B10000000}
#define BQ {B01110000,B10001000,B10101000,B10011000,B01111000,B00001000}
#define BR {B11110000,B10001000,B10001000,B11110000,B10001000,B10001000}
#define BS {B01110000,B10001000,B01100000,B00010000,B10001000,B01110000}
#define BK {B10001000,B10010000,B11100000,B11100000,B10010000,B10001000}
#define BT {B11111000,B00100000,B00100000,B00100000,B00100000,B00100000}
#define BU {B10001000,B10001000,B10001000,B10001000,B10001000,B01110000}
#define BV {B10001000,B10001000,B10001000,B10001000,B01010000,B00100000}
#define BW {B10001000,B10001000,B10101000,B10101000,B10101000,B01010000}
#define BX {B10001000,B01010000,B00100000,B00100000,B01010000,B10001000}
#define BY {B10001000,B01010000,B00100000,B00100000,B00100000,B00100000}
#define BZ {B11111000,B00001000,B00110000,B01100000,B10000000,B11111000}
#define LA{B00000000,B01110000,B00001000,B01111000,B10001000,B01111000}
#define LB{B10000000,B10000000,B10110000,B11001000,B10001000,B11110000}
#define LC{B00000000,B01110000,B10000000,B10000000,B10001000,B01110000}
#define LD{B00001000,B00001000,B01111000,B10001000,B10001000,B01111000}
#define LE{B00000000,B01110000,B10001000,B11111000,B10000000,B01110000}
#define LF{B00110000,B01001000,B01000000,B11100000,B01000000,B01000000}
#define LG{B00000000,B01111000,B10001000,B01111000,B00001000,B01110000}
#define LH{B10000000,B10000000,B10110000,B11001000,B10001000,B10001000}
#define LI{B00100000,B00000000,B01100000,B00100000,B00100000,B01111000}
#define LJ{B00010000,B00000000,B00111000,B00010000,B10010000,B01100000}
#define LK{B10000000,B10010000,B10100000,B11000000,B10100000,B10010000}
#define LL{B01100000,B00100000,B00100000,B00100000,B00100000,B01111000}
#define LM{B00000000,B00000000,B11010000,B10101000,B10101000,B10001000}
#define LN{B00000000,B00000000,B10110000,B11001000,B10001000,B10001000}
#define LO{B00000000,B01110000,B10001000,B10001000,B10001000,B01110000}
#define LP{B00000000,B11110000,B10001000,B11110000,B10000000,B10000000}
#define LQ{B00000000,B01101000,B10011000,B01111000,B00001000,B00001000}
#define LR{B00000000,B00000000,B10110000,B11001000,B10000000,B10000000}
#define LS{B00000000,B01110000,B10000000,B01110000,B00001000,B11110000}
#define LT{B01000000,B01000000,B11100000,B01000000,B01001000,B00110000}
#define LU{B00000000,B00000000,B10001000,B10001000,B10011000,B01101000}
#define LV{B00000000,B00000000,B10001000,B10001000,B01010000,B00100000}
#define LW{B00000000,B00000000,B10001000,B10101000,B10101000,B01010000}
#define LX{B00000000,B10001000,B01010000,B00100000,B01010000,B10001000}
#define LY{B00000000,B10001000,B10001000,B01111000,B00001000,B01110000}
#define LZ{B00000000,B11111000,B00010000,B00100000,B01000000,B11111000}
#define SPACE{B00000000,B00000000,B00000000,B00000000,B00000000,B00000000}
#define NUM0{B01110000,B10011000,B10101000,B10101000,B11001000,B01110000}
#define NUM1{B00100000,B01100000,B10100000,B00100000,B00100000,B01110000}
#define NUM2{B01110000,B10001000,B00001000,B01110000,B10000000,B11111000}
#define NUM3{B11110000,B00001000,B00001000,B01111000,B00001000,B11110000}
#define NUM4{B10001000,B10001000,B10001000,B11111000,B00001000,B00001000}
#define NUM5{B11111000,B10000000,B11110000,B00001000,B10001000,B01110000}
#define NUM6{B11111000,B10000000,B11111000,B10001000,B10001000,B11111000}
#define NUM7{B11111000,B00001000,B00001000,B01111000,B00001000,B00001000}
#define NUM8{B11111000,B10001000,B11111000,B10001000,B10001000,B11111000}
#define NUM9{B11111000,B10001000,B11111000,B00001000,B00001000,B11111000}
#define DEVIDE{B00001000,B00010000,B00100000,B00100000,B01000000,B10000000}
#define TWODOTS{B01100000,B01100000,B00000000,B00000000,B01100000,B01100000}
#define DOT{B00000000,B00000000,B00000000,B00000000,B01100000,B01100000}
#define COMA{B00000000,B00000000,B00000000,B00110000,B00110000,B01100000}
#define LINE{B00000000,B00000000,B11111000,B11111000,B00000000,B00000000}
#define QUASTION{B01110000,B10001000,B00010000,B00100000,B00000000,B00100000}
#define MARK{B00100000,B01110000,B01110000,B00100000,B00000000,B00100000}

#define HEIGHT 6
#define WIDTH 24
#define CHAR_WIDTH 8
#define CHAR_HEIGHT 8
#define BYTES_PER_ROW 3
#define TEXT_SIZE 70

#include <EEPROM.h>

int clock4017_pin = 6;
int reset4017_pin = 7;
int latch_pin = 4;
int clock_pin = 2;
int data_pin = 5;

//scroll section
unsigned long timer1 = 0;
int scroll_offset =19; 

//display text
char display_text[TEXT_SIZE] = "hello world!!!";

char tmp_text[TEXT_SIZE] = "";
int tmp_text_size = 0;
byte simple_text[TEXT_SIZE][6] = {NUM1, NUM2, NUM3, NUM1, NUM2, NUM3, BO};
int simple_text_size = 7;

byte chars_table[70][6] ={BA,BB,BC,BD,BE,BF,BG,BH,BI,BJ,BK,BL,BM,BN,BO,BP,BQ,BR,BS,BT,BU,BV,BW,BX,BY,BZ,SPACE,NUM0,NUM1,NUM2,NUM3,NUM4,NUM5,NUM6,NUM7,NUM8,NUM9,DEVIDE,TWODOTS,DOT,COMA,LINE,QUASTION,MARK,LA,LB,LC,LD,LE,LF,LG,LH,LI,LJ,LK,LL,LM,LN,LO,LP,LQ,LR,LS,LT,LU,LV,LW,LX,LY,LZ};

void setup() {
  pinMode(clock4017_pin, OUTPUT);
  pinMode(reset4017_pin, OUTPUT);
  pinMode(latch_pin, OUTPUT);
  pinMode(clock_pin, OUTPUT);
  pinMode(data_pin, OUTPUT);
  Serial.begin(9600);
  Serial.println("Welcom to led matrix");
  read_text_EEPROM();
  //save_text_EEPROM();
  reset4017();
}

void loop() {
  
  scroll_bytes(simple_text, simple_text_size, 50);
  incoming_text();
  //test();
}

void test() {
  
  display_bytes(simple_text, simple_text_size, 0);

}

void str2byte(char text[TEXT_SIZE], byte bytes[TEXT_SIZE][HEIGHT], int &text_size)
{
  text_size = 0;
  for (int i = 0; i < TEXT_SIZE; i++)
  { 
    if (text[i] == 0)
    {
        text_size--;
        return;    
    }
    for (int r = 0; r < HEIGHT; r++)
    {
      if (text[i] > 64 && text[i] <91)
        bytes[i][r] = chars_table[text[i] - 65][r];
      else if (text[i] > 96 && text[i] <123)
        bytes[i][r] = chars_table[text[i] - 53][r];
      else switch (text[i]) {
      case 32://space        
       bytes[i][r] = chars_table[26][r];
       break;
      case 33://mark
       bytes[i][r] = chars_table[43][r];
       break;
      case 45://line
       
       bytes[i][r] = chars_table[41][r];
       break;                 
       case 44://coma
       
       bytes[i][r] = chars_table[40][r];
       break;
       case 46://dot
       
       bytes[i][r] = chars_table[39][r];
       break;
       case 47://dvide
       
       bytes[i][r] = chars_table[37][r];
       break;
       case 48://0
       
       bytes[i][r] = chars_table[27][r];
       break;
       case 49://1
       
       bytes[i][r] = chars_table[28][r];
       break;
       case 50://2
       
       bytes[i][r] = chars_table[29][r];
       break;
       case 51://3
       
       bytes[i][r] = chars_table[30][r];
       break;
       case 52://4
       
       bytes[i][r] = chars_table[31][r];
       break;
       case 53://5
       
       bytes[i][r] = chars_table[32][r];
       break;
       case 54://6
       
       bytes[i][r] = chars_table[33][r];
       break;
       case 55://7
       
       bytes[i][r] = chars_table[34][r];
       break;
       case 56://8
       
       bytes[i][r] = chars_table[35][r];
       break;
       case 57://9
       
       bytes[i][r] = chars_table[36][r];
       break;
       case 58://tow dots
       
       bytes[i][r] = chars_table[38][r];
       break;
       case 63://quastion
       
       bytes[i][r] = chars_table[42][r];
       break;
       default:
       
       bytes[i][r] = chars_table[26][r];
       break;          
      }
      
      
    }
    
    text_size++;
  }
}
void incoming_text()
{
  while (Serial.available() > 0)
  {
    char inc = Serial.read();
    if (inc == '\n' || tmp_text_size + 1 == TEXT_SIZE)
    {    
      for (int i=0; i < tmp_text_size; i++)
        display_text[i] = tmp_text[i];
      display_text[tmp_text_size] = 0x00;
      
      Serial.print("input text:");
      Serial.println(display_text);
      
      save_text_EEPROM();
      tmp_text_size = 0;
      
      str2byte(display_text, simple_text, simple_text_size);
      scroll_offset = 19;
      
    }    
    tmp_text[tmp_text_size] = inc;
    tmp_text_size++;
         
    
  }
}
void read_text_EEPROM()
{
  char text[TEXT_SIZE] = "";
  for (int i=0; i < TEXT_SIZE; i++)
    text[i] = EEPROM.read(i);
  
  Serial.print("read text from EEPROM: ");
  Serial.println(text);
  if (text != "")
    for (int i = 0; i < TEXT_SIZE; i++)
      display_text[i] =  text[i];
  str2byte(display_text, simple_text, simple_text_size);
}
void save_text_EEPROM(){
  for (int i=0; i < TEXT_SIZE; i++)
    EEPROM.write(i, display_text[i]);
  
}
void scroll_bytes(byte text[][HEIGHT],int text_size, int scroll_delay) {
  display_bytes(text, text_size, scroll_offset);
  if (millis() - timer1 > scroll_delay)
  {
    timer1 = millis();
    scroll_offset -= 1;
  }
  if (scroll_offset < -CHAR_WIDTH * text_size)
    scroll_offset =19;
}
void display_bytes(byte text[][HEIGHT],int text_size, int offset){
  int tmp_offset = 0;
  byte display_matrix[HEIGHT][BYTES_PER_ROW] = {0};
  byte tmp_text[BYTES_PER_ROW + 1][HEIGHT] = {0};
  
  int index = 0;
  //if (offset < 0)
  {
    index = (int) -offset / 8;  
    tmp_offset = offset % 8;
  }
  for (int i = 0; i < BYTES_PER_ROW + 1; i++)
      for (int r = 0; r < HEIGHT; r++)
        if (index + i < text_size && index + i >= 0)
          tmp_text[i][r] = text[index + i][r];
        else
          tmp_text[i][r] = 0;
          
   for(int i = 0; i < BYTES_PER_ROW + 1; i++)
    for(int r = 0; r < HEIGHT; r++)
    {
      byte buf = 0;
      if (tmp_offset <= 0)
      {
        word ubuf = (word) tmp_text[i][r] << -tmp_offset;
        if (i >0)
          display_matrix[r][i-1] |= ubuf >> 8 ; 
        buf = ubuf;        
      } else
      {
        word ubuf = (word) (tmp_text[i][r] << 8) >> tmp_offset;
        if (i < BYTES_PER_ROW -1)
          display_matrix[r][i+1] |= ubuf ; 
        buf = ubuf >> 8;
      }
      if (i < BYTES_PER_ROW)
        display_matrix[r][i] |= buf;
    }
  draw(display_matrix);
  
}


void draw(byte matrix[HEIGHT][BYTES_PER_ROW])
{
  byte no_display[BYTES_PER_ROW] = {0};
  
  for(int r=0; r < HEIGHT; r++)

    {    
      setRows((matrix[r]));
      delayMicroseconds(800);
      setRows(no_display);
      clock4017();
    
    
    }
  delayMicroseconds(800);
  reset4017();
  
  
}

unsigned long inverse(byte mask){
  byte res = 0;
  for (int i=0; i<8; i++)
    res |= bitRead(mask, 8 - i) << i;
  return res;
}


void setRows(byte mask[])
{
        digitalWrite(clock_pin, LOW); 
        digitalWrite(latch_pin, LOW);
        int offset = 0;
	
        for (int i = BYTES_PER_ROW - 1; i >= 0; i--)
        for (int j = 0; j < 8; j++)
          {
            //if (mask[i] & (1 << j) > 0) 
            if (bitRead(mask[i], j) == 1)            
              digitalWrite(data_pin, HIGH); 
  	    else
  	      digitalWrite(data_pin, LOW); 
  
            digitalWrite(clock_pin, HIGH);
  	    digitalWrite(clock_pin, LOW);
  
  	}
        
	digitalWrite(latch_pin, HIGH); 
}
void reset4017() {
    digitalWrite(reset4017_pin, HIGH);  
    digitalWrite(reset4017_pin, LOW);  
  
}
void clock4017() {
    digitalWrite(clock4017_pin, HIGH);  
    digitalWrite(clock4017_pin, LOW);  
  
}
void pressAnyKey()
{
  while (Serial.available() == 0);
  while (Serial.available() > 0)
    Serial.parseInt();
  
  
}
